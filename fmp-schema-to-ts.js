import {createGroupDir, generateGroupIndex, safeCleanDir} from './tools/fs-tools.js';
import {fetchFMPSchema} from './tools/network-tools.js';
import {removePrefixesFromName, sanitizeInterfaceName, transformCase} from './tools/string-tools.js';
import fs from 'fs';
import path from 'path';

const INDENT = 2;

function hasFields(input) {
    return (
        (input.scalar && input.scalar?.length > 0) ||
        (input.tabular && input.tabular?.length > 0)
    );
}

/**
 * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Ç–∏–ø FMP –≤ TypeScript-—Ç–∏–ø.
 * @param {string} fmpType - –¢–∏–ø –ø–æ–ª—è –∏–∑ FMP (–Ω–∞–ø—Ä–∏–º–µ—Ä, "TEXT", "BIGINT").
 * @returns {string} - –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π TS-—Ç–∏–ø.
 */
function getTSType(fmpType) {
    const typeMap = {
        TEXT: 'string',
        BIGINT: 'number',
        D: 'string', // –î–∞—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ "YYYY-MM-DD"
        T: 'string', // –í—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ "HH:MM:SS"
        N: 'string', // –ß–∏—Å–ª–æ, –Ω–æ –≤ FMP –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –∫–∞–∫ —Å—Ç—Ä–æ–∫–∞
        C: 'string', // –°–∏–º–≤–æ–ª—å–Ω—ã–π —Ç–∏–ø
        b: 'number'  // BIGINT (–±–∏–Ω–∞—Ä–Ω—ã–π)
    };
    return typeMap[fmpType] || 'any';
}

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç TS-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö FMP.
 * @private
 */
function generateInterfaceCode(name, data, nameTransform) {
    let code = '/**\n' +
        ' * Generated by FMP Schema to TS.\n' +
        ' * Do not edit manually.\n' +
        ' */\n';

    if (data.scalar?.length === 0 && data.tabular?.length === 0) {
        return '';
    }

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    code += `export type ${transformCase(name, nameTransform)} = `;

    // –°–∫–∞–ª—è—Ä–Ω—ã–µ –ø–æ–ª—è
    if (data.scalar && data.scalar.length > 0) {
        code += '{\n';
        data.scalar.forEach(field => {
            code += `${' '.repeat(INDENT)}"${field.name}": ${getTSType(field.type)};\n`;
        });
        if (data.tabular && data.tabular.length > 0) {
            code += '';
        } else {
            code += '};\n';
        }
    }

    // –¢–∞–±–ª–∏—á–Ω—ã–µ –ø–æ–ª—è (–º–∞—Å—Å–∏–≤—ã)
    if (data.tabular && data.tabular.length > 0) {
        data.tabular.forEach(table => {
            const tableName = table.name ? `_${table?.name}` : '';
            const interfaceName = transformCase(sanitizeInterfaceName(`${name}${tableName}`), nameTransform);

            if (data.scalar && data.scalar.length > 0) {
                code += `${' '.repeat(INDENT)}"${table?.name}": ${interfaceName}[];\n`;
                code += '}\n';
            } else {
                code += `${interfaceName}[];\n`;
            }

            // –í–ª–æ–∂–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã
            code += `\ntype ${interfaceName} = {\n`;
            table.columns.forEach(column => {
                code += `${' '.repeat(INDENT)}"${column.name}": ${getTSType(column.type)};\n`;
            });
            code += '};\n';
        });
    }
    return code;
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å—Ö–µ–º—É –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç TS-—Ñ–∞–π–ª.
 * @param {string} apiUrl - URL API FMP.
 * @param {string} authToken - –¢–æ–∫–µ–Ω –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.
 * @param {string} outputDir - –ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è .ts-—Ñ–∞–π–ª–∞.
 * @param {string[]} removePrefixes - –°–ø–∏—Å–æ–∫ –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.
 * @param {'original' | 'camelCase' | 'pascalCase' | 'snakeCase' | 'constantCase'} nameTransform - –°–ø–æ—Å–æ–± –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–º–µ–Ω–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.
 */
async function generateTSFromFMP(apiUrl, authToken, outputDir, removePrefixes = [], nameTransform = 'original') {
    try {
        console.log('üîó Loading FMP schema...');
        const schema = await fetchFMPSchema(apiUrl, authToken);

        safeCleanDir(outputDir);

        console.log('üìù Generating TS interfaces...');
        // –ì–ª–∞–≤–Ω—ã–π index.ts –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —ç–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –≥—Ä—É–ø–ø
        const mainIndexExports = [];

        for (const [entityName, entity] of Object.entries(schema)) {
            const cleanName = removePrefixesFromName(entityName, removePrefixes);
            const sanitizeName = sanitizeInterfaceName(cleanName);
            const groupName = transformCase(sanitizeName, nameTransform);

            const groupDir = createGroupDir(outputDir, groupName);
            const groupInterfaces = [];

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è Request (–µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ)
            if (entity.input && hasFields(entity.input)) {
                const interfaceCode = generateInterfaceCode(`${groupName}_Request`, entity.input, nameTransform);
                fs.writeFileSync(path.join(groupDir, 'Request.ts'), interfaceCode);
                groupInterfaces.push('Request');
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è Response (–µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ)
            if (entity.output && entity.output.length > 0) {
                const interfaceCode = generateInterfaceCode(`${groupName}_Response`, {tabular: entity.output}, nameTransform);
                fs.writeFileSync(path.join(groupDir, 'Response.ts'), interfaceCode);
                groupInterfaces.push('Response');
            }

            // –°–æ–∑–¥–∞–µ–º index.ts –¥–ª—è –≥—Ä—É–ø–ø—ã
            if (groupInterfaces.length > 0) {
                generateGroupIndex(groupDir, groupInterfaces);
                mainIndexExports.push(`export * as ${groupName} from './${groupName}';`);
            } else {
                fs.rmSync(groupDir, {recursive: true});
            }
        }

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥–ª–∞–≤–Ω–æ–≥–æ index.ts
        fs.writeFileSync(path.join(outputDir, 'index.ts'), mainIndexExports.join('\n'));

    } catch (error) {
        console.error('‚ùå Error:', error.message);
        process.exit(1);
    }
}

export {generateTSFromFMP};
